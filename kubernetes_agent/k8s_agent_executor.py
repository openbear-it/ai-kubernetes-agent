# k8s_agent_executor.py
from a2a.server.agent_execution import AgentExecutor, RequestContext
from a2a.server.events import EventQueue
from a2a.utils import new_agent_text_message
import time
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)



class k8sAgentExecutor(AgentExecutor):
    """Executor that wraps k8sAgent for A2A protocol."""

    def __init__(self):
        self.agent = None  # Lazy initialization
        self.logger = logging.getLogger(__name__)

    async def execute(self, context: RequestContext, event_queue: EventQueue) -> None:
        """
        Executes a user request using k8sAgent.

        A2A strategy:
        - The agent generates all intermediate steps (data retrieval, processing, final answer)
        - The executor filters and sends ONLY the final answer to the A2A queue
        - This avoids "Queue is closed" errors caused by too many intermediate messages
        - Keeps the agent "pure" (always all steps) and the executor "smart" (filtering)
        """
        # Lazy initialization to avoid A2A server startup issues
        if self.agent is None:
            from k8s_agent import k8sAgent
            self.agent = k8sAgent()

        # Extract user request text from A2A context
        user_question = context.get_user_input()

        try:
            self.logger.info(f"Starting execution for user request: {user_question[:100]}...")
            
            final_content = None
            last_progress_time = time.time()
            progress_interval = 5  # Send progress message every 5 seconds
            step_count = 0
            start_time = time.time()
            
            # Iterate through all steps generated by the agent
            self.logger.info("Starting agent stream processing...")
            async for step in self.agent.stream(user_question, selected_tools=[]):
                step_count += 1
                current_time = time.time()
                elapsed_time = current_time - start_time
                
                # Log step information
                self.logger.debug(f"Processing step {step_count} (elapsed: {elapsed_time:.2f}s)")
                if "tool_name" in step:
                    self.logger.info(f"Agent using tool: {step['tool_name']}")
                
                # Send periodic progress updates to keep the queue alive
                if current_time - last_progress_time > progress_interval:
                    progress_msg = f"Still processing your request... (steps: {step_count}, elapsed: {elapsed_time:.2f}s)"
                    self.logger.info(f"Sending progress update: {progress_msg}")
                    try:
                        await event_queue.enqueue_event(
                            new_agent_text_message(progress_msg)
                        )
                        last_progress_time = current_time
                    except Exception as queue_error:
                        if "Queue is closed" in str(queue_error):
                            self.logger.warning("A2A queue closed prematurely, storing response for final delivery")
                            break  # Exit the streaming loop to deliver final response
                        else:
                            raise  # Re-raise unexpected errors
                
                # Check if this is the final answer
                if step.get("is_task_complete", False):
                    self.logger.info("Final answer received from agent")
                    final_content = step["content"]
                    break

                # If it's an intermediate step with content, store it as potential fallback
                elif step.get("content"):
                    self.logger.debug("Storing intermediate step as potential fallback")
                    final_content = step["content"]  # Use latest step as backup

            # Send the final answer to the A2A queue
            total_time = time.time() - start_time
            
            # Function to check queue status and deliver message
            async def safe_enqueue(msg: str) -> bool:
                try:
                    await event_queue.enqueue_event(
                        new_agent_text_message(msg)
                    )
                    return True
                except Exception as e:
                    if "Queue is closed" in str(e):
                        self.logger.error(f"Cannot deliver message - A2A queue closed after {total_time:.2f}s")
                        return False
                    raise
            
            if final_content:
                self.logger.info(f"Attempting to deliver final response after {total_time:.2f}s and {step_count} steps")
                if not await safe_enqueue(final_content):
                    # Log the response that couldn't be delivered for debugging
                    self.logger.warning("Final response that couldn't be delivered:")
                    self.logger.warning(final_content[:500] + "..." if len(final_content) > 500 else final_content)
            else:
                self.logger.warning(f"No content generated after {total_time:.2f}s and {step_count} steps")
                await safe_enqueue("Sorry, I was unable to process your request.")

        except Exception as e:
            error_details = f"Error during agent execution after {time.time() - start_time:.2f}s: {str(e)}"
            self.logger.error(error_details, exc_info=True)
            
            # Detailed error logging
            if hasattr(e, 'response'):
                self.logger.error(f"Response status: {e.response.status_code}")
                self.logger.error(f"Response body: {e.response.text}")

            # More user-friendly error message
            error_message = "Error: Connection error."
            if "Connection" in str(e) or "ConnectError" in str(e):
                error_message = "Connection error. Please check your network connectivity or try again later."
            elif "timeout" in str(e).lower():
                error_message = "Connection timeout. The service may be temporarily unavailable."
            elif "proxy" in str(e).lower():
                error_message = "Proxy connection error. Please check your network settings."

            await event_queue.enqueue_event(
                new_agent_text_message(error_message)
            )

    async def cancel(self, context: RequestContext, event_queue: EventQueue) -> None:
        raise Exception("Cancel is not supported for this agent.")
