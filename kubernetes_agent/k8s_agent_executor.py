# k8s_agent_executor.py
from a2a.server.agent_execution import AgentExecutor, RequestContext
from a2a.server.events import EventQueue
from a2a.utils import new_agent_text_message



class k8sAgentExecutor(AgentExecutor):
    """Executor that wraps k8sAgent for A2A protocol."""

    def __init__(self):
        self.agent = None  # Lazy initialization

    async def execute(self, context: RequestContext, event_queue: EventQueue) -> None:
        """
        Executes a user request using k8sAgent.

        A2A strategy:
        - The agent generates all intermediate steps (data retrieval, processing, final answer)
        - The executor filters and sends ONLY the final answer to the A2A queue
        - This avoids "Queue is closed" errors caused by too many intermediate messages
        - Keeps the agent "pure" (always all steps) and the executor "smart" (filtering)
        """
        # Lazy initialization to avoid A2A server startup issues
        if self.agent is None:
            from k8s_agent import k8sAgent
            self.agent = k8sAgent()

        # Extract user request text from A2A context
        user_question = context.get_user_input()

        try:
            final_content = None
            # Iterate through all steps generated by the agent
            # The agent produces: intermediate steps + final step
            # We want only the final one to avoid premature queue closure
            async for step in self.agent.stream(user_question, selected_tools=[]):
                # Collect only the final answer (is_task_complete=True)
                if step.get("is_task_complete", False):
                    final_content = step["content"]
                    break  # Stop as soon as we have the final answer

            # Send only the final answer to the A2A queue
            if final_content:
                await event_queue.enqueue_event(
                    new_agent_text_message(final_content)
                )
            else:
                # Fallback if no final step was generated (edge case)
                await event_queue.enqueue_event(
                    new_agent_text_message("Sorry, I was unable to process your request.")
                )

        except Exception as e:
            import logging
            logging.basicConfig(level=logging.INFO)
            logger = logging.getLogger(__name__)
            logger.error(f"Error during agent execution: {e}", exc_info=True)

            # More user-friendly error message
            error_message = "Error: Connection error."
            if "Connection" in str(e) or "ConnectError" in str(e):
                error_message = "Connection error. Please check your network connectivity or try again later."
            elif "timeout" in str(e).lower():
                error_message = "Connection timeout. The service may be temporarily unavailable."
            elif "proxy" in str(e).lower():
                error_message = "Proxy connection error. Please check your network settings."

            await event_queue.enqueue_event(
                new_agent_text_message(error_message)
            )

    async def cancel(self, context: RequestContext, event_queue: EventQueue) -> None:
        raise Exception("Cancel is not supported for this agent.")
